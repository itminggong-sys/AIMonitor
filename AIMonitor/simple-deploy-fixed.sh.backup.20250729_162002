#!/bin/bash

# =============================================================================
# AI Monitor 一键部署脚本 - 完整版本
# 版本: 3.8.5
# 描述: 智能检测项目结构，使用现有完整项目或创建新的完整项目结构
# 修复: docker-compose.yml配置不完整问题
# v3.8.5 新增功能：
# - 修复docker-compose.yml缺少aimonitor和frontend服务配置
# - 统一所有服务的网络配置，确保服务间正常通信
# - 优化Docker Compose兼容性，移除过时的version字段
# - 优化所有Dockerfile模板的Go模块处理逻辑
# - 完善演示项目模式下的前端构建配置
# - 提升CentOS环境下的部署成功率
# =============================================================================

set -e  # 遇到错误立即退出

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 项目信息
PROJECT_NAME="AIMonitor"
PROJECT_DIR="$HOME/$PROJECT_NAME"
LOG_FILE="$PROJECT_DIR/deploy.log"

# 获取当前时间的函数
get_timestamp() {
    date '+%Y-%m-%d %H:%M:%S'
}

# 创建日志函数
log() {
    local timestamp=$(get_timestamp)
    if [[ -f "$LOG_FILE" ]] && [[ -w "$(dirname "$LOG_FILE")" ]]; then
        echo "[$timestamp] $1" | tee -a "$LOG_FILE"
    else
        echo "[$timestamp] $1"
    fi
}

log_success() {
    local timestamp=$(get_timestamp)
    if [[ -f "$LOG_FILE" ]] && [[ -w "$(dirname "$LOG_FILE")" ]]; then
        echo -e "${GREEN}✅ [$timestamp] $1${NC}" | tee -a "$LOG_FILE"
    else
        echo -e "${GREEN}✅ [$timestamp] $1${NC}"
    fi
}

log_error() {
    local timestamp=$(get_timestamp)
    if [[ -f "$LOG_FILE" ]] && [[ -w "$(dirname "$LOG_FILE")" ]]; then
        echo -e "${RED}❌ [$timestamp] $1${NC}" | tee -a "$LOG_FILE"
    else
        echo -e "${RED}❌ [$timestamp] $1${NC}"
    fi
}

log_warning() {
    local timestamp=$(get_timestamp)
    if [[ -f "$LOG_FILE" ]] && [[ -w "$(dirname "$LOG_FILE")" ]]; then
        echo -e "${YELLOW}⚠️  [$timestamp] $1${NC}" | tee -a "$LOG_FILE"
    else
        echo -e "${YELLOW}⚠️  [$timestamp] $1${NC}"
    fi
}

log_info() {
    local timestamp=$(get_timestamp)
    if [[ -f "$LOG_FILE" ]] && [[ -w "$(dirname "$LOG_FILE")" ]]; then
        echo -e "${BLUE}ℹ️  [$timestamp] $1${NC}" | tee -a "$LOG_FILE"
    else
        echo -e "${BLUE}ℹ️  [$timestamp] $1${NC}"
    fi
}

# 显示欢迎信息
show_welcome() {
    clear
    echo -e "${BLUE}"
    echo "    ___    ____   __  ___            _ __            "
    echo "   /   |  /  _/  /  |/  /___  ____  (_) /_____  _____"
    echo "  / /| |  / /   / /|_/ / __ \/ __ \/ / __/ __ \/ ___/"
    echo " / ___ |_/ /   / /  / / /_/ / / / / / /_/ /_/ / /    "
    echo "/_/  |_/___/  /_/  /_/\____/_/ /_/_/\__/\____/_/     "
    echo -e "${NC}"
    echo -e "${GREEN}🚀 AI Monitor 智能监控系统 - 完整版一键部署${NC}"
    echo -e "${BLUE}📧 技术支持: support@ai-monitor.com${NC}"
    echo ""
    echo -e "${YELLOW}🎯 本脚本将为您自动完成以下操作:${NC}"
    echo "   1. 检查并安装必要的系统依赖"
    echo "   2. 自动配置Docker环境"
    echo "   3. 部署完整的AI Monitor系统(包含前端界面)"
    echo "   4. 启动Prometheus监控和Elasticsearch搜索"
    echo "   5. 提供访问地址和使用说明"
    echo ""
    echo -e "${GREEN}💡 整个过程大约需要10-15分钟，请保持网络连接${NC}"
    echo ""
    read -p "按回车键开始部署，或按 Ctrl+C 取消..." -r
    echo ""
}

# 创建项目目录
setup_project_dir() {
    log_info "创建项目目录: $PROJECT_DIR"
    mkdir -p "$PROJECT_DIR"
    cd "$PROJECT_DIR"
    
    # 创建子目录
    mkdir -p logs data web configs cmd/server
    
    # 确保日志文件可以创建
    mkdir -p "$(dirname "$LOG_FILE")"
    touch "$LOG_FILE" 2>/dev/null || {
        LOG_FILE="/tmp/aimonitor-deploy.log"
        touch "$LOG_FILE"
        log_warning "使用临时日志文件: $LOG_FILE"
    }
    
    log_success "项目目录创建完成"
}

# 检测操作系统
detect_os() {
    log_info "检测操作系统类型"
    
    # 检查是否在WSL环境中
    if grep -qi microsoft /proc/version 2>/dev/null; then
        log_info "检测到WSL环境"
    fi
    
    # 检查是否为Docker Desktop WSL环境
    if [ -f /etc/os-release ] && grep -q "Docker Desktop" /etc/os-release 2>/dev/null; then
        OS="docker-desktop"
        PACKAGE_MANAGER="none"
        log_info "检测到Docker Desktop WSL环境"
        log_success "检测到操作系统: $OS (Docker已预装)"
        return 0
    fi
    
    # 优先检查/etc/os-release文件
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        case "$ID" in
            "centos"|"rhel"|"fedora")
                OS="centos"
                PACKAGE_MANAGER="yum"
                ;;
            "ubuntu"|"debian")
                OS="ubuntu"
                PACKAGE_MANAGER="apt"
                ;;
            *)
                OS="linux"
                PACKAGE_MANAGER="apt"  # 默认使用apt
                ;;
        esac
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
        if [ -f /etc/redhat-release ]; then
            OS="centos"
            PACKAGE_MANAGER="yum"
        elif [ -f /etc/debian_version ]; then
            OS="ubuntu"
            PACKAGE_MANAGER="apt"
        else
            OS="linux"
            PACKAGE_MANAGER="apt"  # 默认使用apt
        fi
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        OS="macos"
        PACKAGE_MANAGER="brew"
    else
        # 如果无法检测，默认为ubuntu
        OS="ubuntu"
        PACKAGE_MANAGER="apt"
        log_warning "无法准确检测操作系统，默认使用Ubuntu配置"
    fi
    
    log_success "检测到操作系统: $OS (包管理器: $PACKAGE_MANAGER)"
}

# 检查sudo命令是否可用
check_sudo() {
    if command -v sudo &> /dev/null && [ "$(id -u)" != "0" ]; then
        echo "sudo"
    else
        echo ""
    fi
}

# 检查并安装Docker
install_docker() {
    log_info "检查Docker安装状态"
    local SUDO_CMD=$(check_sudo)
    
    # Docker Desktop WSL环境特殊处理
    if [ "$OS" = "docker-desktop" ]; then
        if command -v docker &> /dev/null; then
            log_success "Docker Desktop环境，Docker已预装"
            if docker ps &> /dev/null; then
                log_success "Docker服务正常运行"
                return 0
            else
                log_warning "Docker服务未启动，请确保Docker Desktop正在运行"
                log_info "请在Windows中启动Docker Desktop应用程序"
                return 1
            fi
        else
            log_error "Docker Desktop环境中未找到Docker命令"
            return 1
        fi
    fi
    
    if command -v docker &> /dev/null; then
        log_success "Docker已安装"
        if docker ps &> /dev/null; then
            log_success "Docker服务正常运行"
            return 0
        else
            log_warning "Docker已安装但服务未启动，尝试启动..."
            $SUDO_CMD systemctl start docker 2>/dev/null || $SUDO_CMD service docker start 2>/dev/null || true
            sleep 3
            if docker ps &> /dev/null; then
                log_success "Docker服务启动成功"
                return 0
            fi
        fi
    fi
    
    log_info "开始安装Docker..."
    
    case $OS in
        "centos")
            $SUDO_CMD yum update -y
            $SUDO_CMD yum install -y yum-utils device-mapper-persistent-data lvm2
            $SUDO_CMD yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
            $SUDO_CMD yum install -y docker-ce docker-ce-cli containerd.io
            $SUDO_CMD systemctl start docker
            $SUDO_CMD systemctl enable docker
            ;;
        "ubuntu"|"linux")
            $SUDO_CMD apt update -y
            $SUDO_CMD apt install -y apt-transport-https ca-certificates curl gnupg lsb-release
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | $SUDO_CMD gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 2>/dev/null || true
            echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs 2>/dev/null || echo focal) stable" | $SUDO_CMD tee /etc/apt/sources.list.d/docker.list > /dev/null
            $SUDO_CMD apt update -y
            $SUDO_CMD apt install -y docker-ce docker-ce-cli containerd.io
            $SUDO_CMD systemctl start docker 2>/dev/null || $SUDO_CMD service docker start 2>/dev/null || true
            $SUDO_CMD systemctl enable docker 2>/dev/null || true
            ;;
        "macos")
            if ! command -v brew &> /dev/null; then
                log_error "请先安装Homebrew: https://brew.sh/"
                exit 1
            fi
            brew install --cask docker
            log_warning "请手动启动Docker Desktop应用程序"
            read -p "启动Docker Desktop后按回车继续..." -r
            ;;
        *)
            log_error "不支持的操作系统: $OS，请手动安装Docker"
            exit 1
            ;;
    esac
    
    # 添加用户到docker组
    if [ "$OS" != "macos" ] && [ "$(id -u)" != "0" ]; then
        $SUDO_CMD usermod -aG docker $USER 2>/dev/null || true
        log_warning "已将用户添加到docker组，可能需要重新登录"
    fi
    
    # 验证Docker安装
    sleep 5
    if docker ps &> /dev/null || $SUDO_CMD docker ps &> /dev/null; then
        log_success "Docker安装并启动成功"
    else
        log_error "Docker安装失败，请检查系统环境"
        exit 1
    fi
}

# 安装Docker Compose
install_docker_compose() {
    log_info "检查Docker Compose安装状态"
    local SUDO_CMD=$(check_sudo)
    
    # Docker Desktop环境通常已包含docker-compose
    if [ "$OS" = "docker-desktop" ]; then
        if command -v docker-compose &> /dev/null || docker compose version &> /dev/null; then
            log_success "Docker Desktop环境，Docker Compose已预装"
            return 0
        else
            log_warning "Docker Desktop环境中未找到Docker Compose"
        fi
    fi
    
    if command -v docker-compose &> /dev/null; then
        log_success "Docker Compose已安装"
        return 0
    fi
    
    log_info "开始安装Docker Compose..."
    
    case $OS in
        "centos"|"ubuntu"|"linux")
            $SUDO_CMD curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            $SUDO_CMD chmod +x /usr/local/bin/docker-compose
            ;;
        "macos")
            brew install docker-compose
            ;;
        *)
            log_error "不支持的操作系统: $OS，请手动安装Docker Compose"
            exit 1
            ;;
    esac
    
    if command -v docker-compose &> /dev/null; then
        log_success "Docker Compose安装成功"
    else
        log_error "Docker Compose安装失败"
        exit 1
    fi
}

# 创建项目文件
create_project_files() {
    log_info "检查项目结构"
    
    # 检查是否存在完整的项目结构
    if [ -d "internal" ] && [ -f "cmd/server/main.go" ] && [ -f "go.mod" ]; then
        log_success "检测到完整的项目结构，使用现有文件"
        log_info "项目模块: $(head -1 go.mod | cut -d' ' -f2)"
        
        # 确保go.sum文件存在，避免Docker构建时的"go.sum not found"错误
        if [ ! -f "go.sum" ]; then
            log_info "go.sum文件不存在，创建空的go.sum文件"
            touch go.sum
            log_success "已创建go.sum文件，Docker构建时会自动更新"
        else
            log_success "go.sum文件已存在"
        fi
        
        # 只创建必要的配置文件
        log_info "创建Docker和配置文件"
        create_docker_configs
        return 0
    fi
    
    log_info "未检测到完整项目结构，创建完整的AI Monitor项目"
    
    # 创建完整的项目目录结构
    create_full_project_structure
    
    # 创建Docker配置文件
    create_docker_configs
    
    # 创建前端项目
    create_frontend
    
    log_success "完整项目文件创建完成"
}

# 创建Docker和配置文件
create_docker_configs() {
    log_info "创建Docker和配置文件"
    
    # 检查是否为完整项目结构
    local is_full_project=false
    if [ -d "internal" ] && [ -f "cmd/server/main.go" ] && [ -f "go.mod" ]; then
        is_full_project=true
        log_info "为完整项目创建Docker配置"
    else
        log_info "为演示项目创建Docker配置"
    fi
    
    # 创建完整的docker-compose.yml
    cat > docker-compose.yml << 'EOF'
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    container_name: ai-monitor-postgres
    environment:
      POSTGRES_DB: ai_monitor
      POSTGRES_USER: ai_monitor
      POSTGRES_PASSWORD: password
      POSTGRES_INITDB_ARGS: "--encoding=UTF-8 --lc-collate=C --lc-ctype=C"
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ai_monitor -d ai_monitor"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: ai-monitor-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  prometheus:
    image: prom/prometheus:latest
    container_name: ai-monitor-prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./configs/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=200h'
      - '--web.enable-lifecycle'
    restart: unless-stopped

  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
    container_name: ai-monitor-elasticsearch
    environment:
      - discovery.type=single-node
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
      - xpack.security.enabled=false
    ports:
      - "9200:9200"
      - "9300:9300"
    volumes:
      - elasticsearch_data:/usr/share/elasticsearch/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:9200/_cluster/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5

  aimonitor:
    image: golang:1.21-alpine
    working_dir: /app
    command: sh -c "apk add --no-cache git ca-certificates curl && go env -w GOPROXY=https://goproxy.cn,direct && go env -w GOSUMDB=sum.golang.org && go env -w GO111MODULE=on && echo 'Initializing Go modules...' && ([ ! -f go.sum ] && touch go.sum || true) && echo 'Starting Go module download with retry...' && for i in 1 2 3; do echo \"Attempt $i/3\" && go mod download -x && break || (echo \"Download failed, retrying in 5s...\" && sleep 5); done && echo 'Go modules downloaded successfully' && go mod tidy && echo 'Starting application...' && go run cmd/server/main.go"
    ports:
      - "8080:8080"
    environment:
      - DB_HOST=postgres
      - REDIS_HOST=redis
      - GIN_MODE=release
      - GOPROXY=https://goproxy.cn,direct
      - GOSUMDB=sum.golang.org
      - GO111MODULE=on
      - CGO_ENABLED=0
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - .:/app
      - ./logs:/app/logs
    restart: unless-stopped

  frontend:
    image: node:18-alpine
    working_dir: /app
    command: sh -c "npm config set registry https://registry.npmmirror.com && npm install && npm run dev -- --host 0.0.0.0 --port 3000"
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=development
      - VITE_API_BASE_URL=http://localhost:8080
    volumes:
      - ./web:/app
      - /app/node_modules
    restart: unless-stopped
    depends_on:
      aimonitor:
        condition: service_started
    healthcheck:
      test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:3000 || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  postgres_data:
  redis_data:
  prometheus_data:
  elasticsearch_data:

networks:
  default:
    name: ai-monitor-network
EOF

    # 创建Prometheus配置
    cat > configs/prometheus.yml << 'EOF'
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  # - "first_rules.yml"
  # - "second_rules.yml"

scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']

  - job_name: 'ai-monitor'
    static_configs:
      - targets: ['aimonitor:8080']
    metrics_path: '/metrics'
    scrape_interval: 5s
EOF

    # 只在演示项目模式下创建Dockerfile
    if [ "$is_full_project" = false ]; then
        cat > Dockerfile << 'EOF'
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN apk add --no-cache git ca-certificates curl && \
    go env -w GOPROXY=https://goproxy.cn,direct && \
    go env -w GOSUMDB=sum.golang.org && \
    go env -w GO111MODULE=on && \
    ([ ! -f go.sum ] && touch go.sum || true) && \
    for i in 1 2 3; do echo "Go mod download attempt $i/3" && go mod download -x && break || (echo "Download failed, retrying in 5s..." && sleep 5); done

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main cmd/server/main.go

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/main .
COPY --from=builder /app/configs ./configs
EXPOSE 8080
CMD ["./main"]
EOF
        log_info "Go后端Dockerfile创建完成"
    else
        log_info "完整项目模式：跳过Dockerfile创建，使用直接运行方式"
    fi

    # 创建前端Dockerfile
    mkdir -p web
    cat > web/Dockerfile << 'EOF'
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm config set registry https://registry.npmmirror.com && npm install

COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf
EXPOSE 3000
CMD ["nginx", "-g", "daemon off;"]
EOF

    # 创建nginx配置
    cat > web/nginx.conf << 'EOF'
events {
    worker_connections 1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    
    server {
        listen 3000;
        server_name localhost;
        
        location / {
            root /usr/share/nginx/html;
            index index.html index.htm;
            try_files $uri $uri/ /index.html;
        }
        
        location /api {
            proxy_pass http://aimonitor:8080;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
    }
}
EOF

    log_success "Docker和配置文件创建完成"
}

# 创建完整的项目结构
create_full_project_structure() {
    log_info "创建完整的AI Monitor项目结构"
    
    # 创建目录结构
    mkdir -p cmd/server
    mkdir -p internal/{auth,cache,config,database,handlers,logger,metrics,middleware,models,router,scheduler,services,utils,websocket}
    mkdir -p configs
    mkdir -p data
    mkdir -p deploy/{nginx}
    
    # 创建完整的main.go（与实际项目一致）
    cat > cmd/server/main.go << 'EOF'
package main

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"ai-monitor/internal/cache"
	"ai-monitor/internal/config"
	"ai-monitor/internal/database"
	"ai-monitor/internal/logger"
	"ai-monitor/internal/middleware"
	"ai-monitor/internal/router"
	"ai-monitor/internal/services"

	"github.com/gin-gonic/gin"
	"github.com/sirupsen/logrus"
)

// @title AI监控系统 API
// @version 1.0
// @description AI智能监控系统的RESTful API文档
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name MIT
// @license.url https://opensource.org/licenses/MIT

// @host localhost:8080
// @BasePath /api/v1

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

func main() {
	// 初始化配置
	// 检查是否指定了配置文件
	configFile := "config"
	if len(os.Args) > 1 {
		configFile = os.Args[1]
	}
	
	cfg, err := config.LoadWithFile(configFile)
	if err != nil {
		logrus.Fatalf("Failed to load config: %v", err)
	}

	// 初始化日志
	logger.Init(logger.Config{
		Level:      cfg.Logging.Level,
		Format:     cfg.Logging.Format,
		Output:     cfg.Logging.Output,
		FilePath:   cfg.Logging.FilePath,
		MaxSize:    cfg.Logging.MaxSize,
		MaxBackups: cfg.Logging.MaxBackups,
		MaxAge:     cfg.Logging.MaxAge,
		Compress:   cfg.Logging.Compress,
	})
	log := logrus.WithField("component", "main")

	log.Info("Starting AI Monitor System...")

	// 设置Gin模式
	gin.SetMode(cfg.Server.Mode)

	// 初始化数据库
	if err := database.Initialize(&cfg.Database); err != nil {
		log.Fatal("Failed to initialize database:", err)
	}
	defer func() {
		if database.DB != nil {
			if sqlDB, err := database.DB.DB(); err == nil {
				sqlDB.Close()
			}
		}
	}()

	// 初始化Redis缓存
	if err := cache.Initialize(&cfg.Redis); err != nil {
		log.Fatal("Failed to initialize Redis:", err)
	}
	defer cache.Close()

	// 运行数据库迁移
	if err := database.Migrate(); err != nil {
		log.Fatalf("Failed to run database migrations: %v", err)
	}

	// 初始化服务
	services, err := services.NewServices(cfg, database.DB)
	if err != nil {
		log.Fatalf("Failed to initialize services: %v", err)
	}

	// 启动后台服务
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	if err := services.Start(ctx); err != nil {
		log.Fatalf("Failed to start services: %v", err)
	}

	// 初始化中间件依赖
	middleware.InitializeMiddleware(services.GetJWTManager(), services.GetCacheManager(), cfg)

	// 初始化路由
	r := router.Setup(cfg, services)

	// 创建HTTP服务器
	srv := &http.Server{
		Addr:           fmt.Sprintf("%s:%d", cfg.Server.Host, cfg.Server.Port),
		Handler:        r,
		ReadTimeout:    cfg.Server.ReadTimeout,
		WriteTimeout:   cfg.Server.WriteTimeout,
		IdleTimeout:    cfg.Server.IdleTimeout,
		MaxHeaderBytes: cfg.Server.MaxHeaderBytes,
	}

	// 启动服务器
	go func() {
		log.Infof("Server starting on %s:%d", cfg.Server.Host, cfg.Server.Port)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("Failed to start server: %v", err)
		}
	}()

	// 等待中断信号
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	log.Info("Shutting down server...")

	// 优雅关闭
	shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer shutdownCancel()

	// 停止后台服务
	cancel()
	services.Stop()

	// 关闭HTTP服务器
	if err := srv.Shutdown(shutdownCtx); err != nil {
		log.Errorf("Server forced to shutdown: %v", err)
	} else {
		log.Info("Server exited gracefully")
	}
}

// 健康检查处理器
func healthCheck(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"status":    "ok",
		"timestamp": time.Now().Unix(),
		"version":   "1.0.0",
		"service":   "ai-monitor",
	})
}

// 版本信息处理器
func versionInfo(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"version":     "1.0.0",
		"build_time":  "2024-01-01T00:00:00Z",
		"git_commit":  "unknown",
		"go_version":  "go1.21",
		"service":     "ai-monitor",
		"description": "AI智能监控系统",
	})
}
EOF

    # 创建完整的go.mod（与实际项目一致）
    cat > go.mod << 'EOF'
module ai-monitor

go 1.23.0

toolchain go1.24.4

require (
	github.com/gin-contrib/cors v1.7.6
	github.com/gin-contrib/pprof v1.5.3
	github.com/gin-gonic/gin v1.10.1
	github.com/glebarez/sqlite v1.11.0
	github.com/go-sql-driver/mysql v1.8.1
	github.com/golang-jwt/jwt/v5 v5.0.0
	github.com/google/uuid v1.6.0
	github.com/gorilla/websocket v1.5.0
	github.com/prometheus/client_golang v1.17.0
	github.com/prometheus/common v0.45.0
	github.com/redis/go-redis/v9 v9.11.0
	github.com/robfig/cron/v3 v3.0.1
	github.com/sashabaranov/go-openai v1.17.7
	github.com/sirupsen/logrus v1.9.3
	github.com/spf13/viper v1.17.0
	github.com/swaggo/files v1.0.1
	github.com/swaggo/gin-swagger v1.6.0
	golang.org/x/crypto v0.39.0
	gopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df
	gorm.io/driver/mysql v1.6.0
	gorm.io/driver/postgres v1.5.4
	gorm.io/driver/sqlite v1.5.6
	gorm.io/gorm v1.30.0
)
EOF

    # 创建内部包的基础文件
    create_internal_packages
    
    # 创建配置文件
    create_config_files
    
    # 创建数据库初始化文件
    create_database_files
    
    log_success "完整项目结构创建完成"
}

# 创建内部包
create_internal_packages() {
    log_info "创建内部包文件"
    
    # 创建配置包
    cat > internal/config/config.go << 'EOF'
package config

import (
	"time"
	"github.com/spf13/viper"
)

type Config struct {
	Server   ServerConfig   `mapstructure:"server"`
	Database DatabaseConfig `mapstructure:"database"`
	Redis    RedisConfig    `mapstructure:"redis"`
	Logging  LoggingConfig  `mapstructure:"logging"`
	JWT      JWTConfig      `mapstructure:"jwt"`
}

type ServerConfig struct {
	Host           string        `mapstructure:"host"`
	Port           int           `mapstructure:"port"`
	Mode           string        `mapstructure:"mode"`
	ReadTimeout    time.Duration `mapstructure:"read_timeout"`
	WriteTimeout   time.Duration `mapstructure:"write_timeout"`
	IdleTimeout    time.Duration `mapstructure:"idle_timeout"`
	MaxHeaderBytes int           `mapstructure:"max_header_bytes"`
}

type DatabaseConfig struct {
	Type     string `mapstructure:"type"`
	Host     string `mapstructure:"host"`
	Port     int    `mapstructure:"port"`
	User     string `mapstructure:"user"`
	Password string `mapstructure:"password"`
	Name     string `mapstructure:"name"`
	SSLMode  string `mapstructure:"ssl_mode"`
}

type RedisConfig struct {
	Host     string `mapstructure:"host"`
	Port     int    `mapstructure:"port"`
	Password string `mapstructure:"password"`
	DB       int    `mapstructure:"db"`
}

type LoggingConfig struct {
	Level      string `mapstructure:"level"`
	Format     string `mapstructure:"format"`
	Output     string `mapstructure:"output"`
	FilePath   string `mapstructure:"file_path"`
	MaxSize    int    `mapstructure:"max_size"`
	MaxBackups int    `mapstructure:"max_backups"`
	MaxAge     int    `mapstructure:"max_age"`
	Compress   bool   `mapstructure:"compress"`
}

type JWTConfig struct {
	Secret     string        `mapstructure:"secret"`
	Expiration time.Duration `mapstructure:"expiration"`
}

func LoadWithFile(configFile string) (*Config, error) {
	viper.SetConfigName(configFile)
	viper.SetConfigType("yaml")
	viper.AddConfigPath(".")
	viper.AddConfigPath("./configs")
	viper.AddConfigPath("/etc/ai-monitor/")

	// 设置默认值
	setDefaults()

	if err := viper.ReadInConfig(); err != nil {
		return nil, err
	}

	var config Config
	if err := viper.Unmarshal(&config); err != nil {
		return nil, err
	}

	return &config, nil
}

func setDefaults() {
	viper.SetDefault("server.host", "0.0.0.0")
	viper.SetDefault("server.port", 8080)
	viper.SetDefault("server.mode", "release")
	viper.SetDefault("server.read_timeout", "30s")
	viper.SetDefault("server.write_timeout", "30s")
	viper.SetDefault("server.idle_timeout", "60s")
	viper.SetDefault("server.max_header_bytes", 1048576)

	viper.SetDefault("database.type", "postgres")
	viper.SetDefault("database.host", "localhost")
	viper.SetDefault("database.port", 5432)
	viper.SetDefault("database.user", "aimonitor")
	viper.SetDefault("database.password", "aimonitor123")
	viper.SetDefault("database.name", "ai_monitor")
	viper.SetDefault("database.ssl_mode", "disable")

	viper.SetDefault("redis.host", "localhost")
	viper.SetDefault("redis.port", 6379)
	viper.SetDefault("redis.password", "")
	viper.SetDefault("redis.db", 0)

	viper.SetDefault("logging.level", "info")
	viper.SetDefault("logging.format", "json")
	viper.SetDefault("logging.output", "stdout")
	viper.SetDefault("logging.file_path", "logs/app.log")
	viper.SetDefault("logging.max_size", 100)
	viper.SetDefault("logging.max_backups", 3)
	viper.SetDefault("logging.max_age", 28)
	viper.SetDefault("logging.compress", true)

	viper.SetDefault("jwt.secret", "your-secret-key")
	viper.SetDefault("jwt.expiration", "24h")
}
EOF

    # 创建数据库包
    cat > internal/database/database.go << 'EOF'
package database

import (
	"fmt"
	"ai-monitor/internal/models"
	"gorm.io/driver/postgres"
	"gorm.io/driver/mysql"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

var DB *gorm.DB

type DatabaseConfig struct {
	Type     string `mapstructure:"type"`
	Host     string `mapstructure:"host"`
	Port     int    `mapstructure:"port"`
	User     string `mapstructure:"user"`
	Password string `mapstructure:"password"`
	Name     string `mapstructure:"name"`
	SSLMode  string `mapstructure:"ssl_mode"`
}

func Initialize(config *DatabaseConfig) error {
	var dialector gorm.Dialector

	switch config.Type {
	case "postgres":
		dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%d sslmode=%s",
			config.Host, config.User, config.Password, config.Name, config.Port, config.SSLMode)
		dialector = postgres.Open(dsn)
	case "mysql":
		dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&parseTime=True&loc=Local",
			config.User, config.Password, config.Host, config.Port, config.Name)
		dialector = mysql.Open(dsn)
	case "sqlite":
		dialector = sqlite.Open(config.Name)
	default:
		return fmt.Errorf("unsupported database type: %s", config.Type)
	}

	db, err := gorm.Open(dialector, &gorm.Config{
		Logger: logger.Default.LogMode(logger.Info),
	})
	if err != nil {
		return err
	}

	DB = db
	return nil
}

func Migrate() error {
	return DB.AutoMigrate(
		&models.User{},
		&models.Agent{},
		&models.Alert{},
		&models.Metric{},
	)
}
EOF

    # 创建模型包
    cat > internal/models/models.go << 'EOF'
package models

import (
	"time"
	"gorm.io/gorm"
)

type User struct {
	ID        uint           `json:"id" gorm:"primarykey"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
	DeletedAt gorm.DeletedAt `json:"-" gorm:"index"`
	Username  string         `json:"username" gorm:"uniqueIndex;not null"`
	Email     string         `json:"email" gorm:"uniqueIndex"`
	Password  string         `json:"-" gorm:"not null"`
	Role      string         `json:"role" gorm:"default:user"`
	IsActive  bool           `json:"is_active" gorm:"default:true"`
}

type Agent struct {
	ID            uint           `json:"id" gorm:"primarykey"`
	CreatedAt     time.Time      `json:"created_at"`
	UpdatedAt     time.Time      `json:"updated_at"`
	DeletedAt     gorm.DeletedAt `json:"-" gorm:"index"`
	Name          string         `json:"name" gorm:"not null"`
	Type          string         `json:"type" gorm:"not null"`
	Host          string         `json:"host" gorm:"not null"`
	Port          int            `json:"port"`
	Status        string         `json:"status" gorm:"default:offline"`
	LastHeartbeat *time.Time     `json:"last_heartbeat"`
	Config        string         `json:"config" gorm:"type:text"`
}

type Alert struct {
	ID          uint           `json:"id" gorm:"primarykey"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
	DeletedAt   gorm.DeletedAt `json:"-" gorm:"index"`
	Title       string         `json:"title" gorm:"not null"`
	Description string         `json:"description" gorm:"type:text"`
	Severity    string         `json:"severity" gorm:"not null"`
	Status      string         `json:"status" gorm:"default:open"`
	AgentID     uint           `json:"agent_id"`
	Agent       Agent          `json:"agent" gorm:"foreignKey:AgentID"`
}

type Metric struct {
	ID        uint           `json:"id" gorm:"primarykey"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
	DeletedAt gorm.DeletedAt `json:"-" gorm:"index"`
	Name      string         `json:"name" gorm:"not null"`
	Value     float64        `json:"value"`
	Unit      string         `json:"unit"`
	AgentID   uint           `json:"agent_id"`
	Agent     Agent          `json:"agent" gorm:"foreignKey:AgentID"`
	Timestamp time.Time      `json:"timestamp"`
}
EOF

    # 创建其他必要的包文件（简化版本）
    echo 'package cache' > internal/cache/redis.go
    echo 'package logger' > internal/logger/logger.go
    echo 'package services' > internal/services/services.go
    echo 'package router' > internal/router/router.go
    echo 'package middleware' > internal/middleware/simple.go
    echo 'package handlers' > internal/handlers/handlers.go
    echo 'package auth' > internal/auth/jwt.go
    echo 'package utils' > internal/utils/utils.go
    echo 'package websocket' > internal/websocket/websocket.go
    echo 'package metrics' > internal/metrics/metrics.go
    echo 'package scheduler' > internal/scheduler/scheduler.go
}

# 创建配置文件
create_config_files() {
    log_info "创建配置文件"
    
    cat > configs/config.yaml << 'EOF'
server:
  host: "0.0.0.0"
  port: 8080
  mode: "release"
  read_timeout: "30s"
  write_timeout: "30s"
  idle_timeout: "60s"
  max_header_bytes: 1048576

database:
  type: "postgres"
  host: "postgres"
  port: 5432
  user: "aimonitor"
  password: "aimonitor123"
  name: "ai_monitor"
  ssl_mode: "disable"

redis:
  host: "redis"
  port: 6379
  password: ""
  db: 0

logging:
  level: "info"
  format: "json"
  output: "stdout"
  file_path: "logs/app.log"
  max_size: 100
  max_backups: 3
  max_age: 28
  compress: true

jwt:
  secret: "your-secret-key-change-in-production"
  expiration: "24h"
EOF

    cat > configs/config.dev.yaml << 'EOF'
server:
  host: "localhost"
  port: 8080
  mode: "debug"

database:
  type: "sqlite"
  name: "data/aimonitor.db"

redis:
  host: "localhost"
  port: 6379

logging:
  level: "debug"
  format: "text"
  output: "stdout"
EOF
}

# 创建数据库文件
create_database_files() {
    log_info "创建数据库初始化文件"
    
    cat > init.sql << 'EOF'
CREATE DATABASE IF NOT EXISTS ai_monitor;
\c ai_monitor;

CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    email VARCHAR(100),
    role VARCHAR(20) DEFAULT 'user',
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS agents (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    type VARCHAR(50) NOT NULL,
    host VARCHAR(255) NOT NULL,
    port INTEGER,
    status VARCHAR(20) DEFAULT 'offline',
    last_heartbeat TIMESTAMP,
    config TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS alerts (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    severity VARCHAR(20) NOT NULL,
    status VARCHAR(20) DEFAULT 'open',
    agent_id INTEGER REFERENCES agents(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS metrics (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    value DECIMAL(10,2),
    unit VARCHAR(20),
    agent_id INTEGER REFERENCES agents(id),
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO users (username, password, email, role) VALUES 
('admin', '$2a$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', 'admin@aimonitor.com', 'admin')
ON CONFLICT (username) DO NOTHING;

INSERT INTO agents (name, type, host, status) VALUES 
('系统监控代理', 'system', 'localhost', 'online'),
('网络监控代理', 'network', 'localhost', 'online'),
('应用监控代理', 'application', 'localhost', 'online');
EOF
}

# 创建Docker和配置文件
create_docker_configs() {
    log_info "创建Docker配置文件"
    
    # 创建docker-compose.yml（适配现有项目）
    cat > docker-compose.yml << 'EOF'
version: '3.8'

services:
  # AI Monitor 后端服务
  aimonitor:
    build: .
    container_name: aimonitor-backend
    ports:
      - "8080:8080"
    environment:
      - GIN_MODE=release
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_USER=aimonitor
      - DB_PASSWORD=aimonitor123
      - DB_NAME=ai_monitor
      - REDIS_HOST=redis
      - REDIS_PORT=6379
    depends_on:
      - postgres
      - redis
    volumes:
      - ./configs:/app/configs
      - ./data:/app/data
    networks:
      - aimonitor-network
    restart: unless-stopped

  # 前端服务
  frontend:
    build:
      context: ./web
      dockerfile: Dockerfile
    container_name: aimonitor-frontend
    ports:
      - "3000:3000"
    environment:
      - VITE_API_BASE_URL=http://localhost:8080
    depends_on:
      - aimonitor
    networks:
      - aimonitor-network
    restart: unless-stopped

  # PostgreSQL 数据库
  postgres:
    image: postgres:15-alpine
    container_name: aimonitor-postgres
    environment:
      POSTGRES_DB: ai_monitor
      POSTGRES_USER: aimonitor
      POSTGRES_PASSWORD: aimonitor123
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - aimonitor-network
    restart: unless-stopped

  # Redis 缓存
  redis:
    image: redis:7-alpine
    container_name: aimonitor-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - aimonitor-network
    restart: unless-stopped

  # Prometheus 监控
  prometheus:
    image: prom/prometheus:latest
    container_name: aimonitor-prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./configs/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
    networks:
      - aimonitor-network
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
  prometheus_data:

networks:
  aimonitor-network:
    driver: bridge
EOF

    # 创建Dockerfile（如果不存在）
    if [ ! -f "Dockerfile" ]; then
        cat > Dockerfile << 'EOF'
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN apk add --no-cache git ca-certificates curl && \
    go env -w GOPROXY=https://goproxy.cn,direct && \
    go env -w GOSUMDB=sum.golang.org && \
    go env -w GO111MODULE=on && \
    ([ ! -f go.sum ] && touch go.sum || true) && \
    for i in 1 2 3; do echo "Go mod download attempt $i/3" && go mod download -x && break || (echo "Download failed, retrying in 5s..." && sleep 5); done

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main cmd/server/main.go

FROM alpine:latest
RUN apk --no-cache add ca-certificates tzdata
WORKDIR /root/

COPY --from=builder /app/main .
COPY --from=builder /app/configs ./configs

EXPOSE 8080
CMD ["./main"]
EOF
    fi

    # 创建前端Dockerfile（如果不存在）
    if [ ! -f "web/Dockerfile" ]; then
        mkdir -p web
        cat > web/Dockerfile << 'EOF'
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm config set registry https://registry.npmmirror.com && npm install

COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 3000
CMD ["nginx", "-g", "daemon off;"]
EOF

        # 创建nginx配置
        cat > web/nginx.conf << 'EOF'
events {
    worker_connections 1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    
    server {
        listen 3000;
        server_name localhost;
        
        location / {
            root /usr/share/nginx/html;
            index index.html index.htm;
            try_files $uri $uri/ /index.html;
        }
        
        location /api {
            proxy_pass http://aimonitor:8080;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
    }
}
EOF
    fi

    log_success "Docker和配置文件创建完成"
}

# 创建现代化前端
create_frontend() {
    # 检查是否存在前端项目
    if [ -f "web/package.json" ] && [ -d "web/src" ]; then
        log_success "检测到现有前端项目，跳过创建"
        return 0
    fi
    
    log_info "创建现代化前端界面"
    
    # 创建package.json
    cat > web/package.json << 'EOF'
{
  "name": "ai-monitor-web",
  "version": "1.0.0",
  "description": "AI Monitor System Web Frontend",
  "private": true,
  "scripts": {
    "dev": "vite --host 0.0.0.0",
    "build": "vite build --mode production",
    "preview": "vite preview"
  },
  "dependencies": {
    "@ant-design/icons": "^5.2.6",
    "antd": "^5.12.8",
    "axios": "^1.6.2",
    "dayjs": "^1.11.10",
    "echarts": "^5.4.3",
    "echarts-for-react": "^3.0.2",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.8.1"
  },
  "devDependencies": {
    "@types/node": "^20.3.0",
    "@types/react": "^18.2.43",
    "@types/react-dom": "^18.2.17",
    "@typescript-eslint/eslint-plugin": "^5.59.0",
    "@typescript-eslint/parser": "^5.59.0",
    "@vitejs/plugin-react": "^4.2.1",
    "eslint": "^8.42.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.0",
    "typescript": "^5.2.2",
    "vite": "^5.0.8"
  },
  "engines": {
    "node": ">=16.0.0",
    "npm": ">=8.0.0"
  }
}
EOF

    # 创建vite.config.ts
    cat > web/vite.config.ts << 'EOF'
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    host: '0.0.0.0',
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://aimonitor:8080',
        changeOrigin: true
      }
    }
  }
})
EOF

    # 创建index.html
    cat > web/index.html << 'EOF'
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/vite.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI Monitor 智能监控系统</title>
</head>
<body>
  <div id="root"></div>
  <script type="module" src="/src/main.tsx"></script>
</body>
</html>
EOF

    # 创建TypeScript配置
    cat > web/tsconfig.json << 'EOF'
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
EOF

    # 创建Node.js TypeScript配置
    cat > web/tsconfig.node.json << 'EOF'
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
EOF

    # 创建React主文件
    mkdir -p web/src
    cat > web/src/main.tsx << 'EOF'
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import 'antd/dist/reset.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
EOF

    # 创建简化的App组件
    cat > web/src/App.tsx << 'EOF'
import React, { useState, useEffect } from 'react';
import { Layout, Menu, Card, Row, Col, Statistic, Table, Tag, Button, Space } from 'antd';
import {
  DashboardOutlined,
  MonitorOutlined,
  SettingOutlined,
  AlertOutlined,
  DatabaseOutlined
} from '@ant-design/icons';
import axios from 'axios';

const { Header, Sider, Content } = Layout;

interface SystemStatus {
  message: string;
  version: string;
  uptime: string;
  services: {
    database: string;
    redis: string;
    prometheus: string;
    elasticsearch: string;
  };
}

interface Agent {
  id: number;
  name: string;
  status: string;
  type: string;
}

const App: React.FC = () => {
  const [collapsed, setCollapsed] = useState(false);
  const [selectedKey, setSelectedKey] = useState('1');
  const [systemStatus, setSystemStatus] = useState<SystemStatus | null>(null);
  const [agents, setAgents] = useState<Agent[]>([]);

  useEffect(() => {
    fetchSystemStatus();
    fetchAgents();
    
    const interval = setInterval(() => {
      fetchSystemStatus();
      fetchAgents();
    }, 30000);

    return () => clearInterval(interval);
  }, []);

  const fetchSystemStatus = async () => {
    try {
      const response = await axios.get('/api/v1/status');
      setSystemStatus(response.data);
    } catch (error) {
      console.error('Failed to fetch system status:', error);
    }
  };

  const fetchAgents = async () => {
    try {
      const response = await axios.get('/api/v1/agents');
      setAgents(response.data.agents);
    } catch (error) {
      console.error('Failed to fetch agents:', error);
    }
  };

  const menuItems = [
    {
      key: '1',
      icon: <DashboardOutlined />,
      label: '仪表板',
    },
    {
      key: '2',
      icon: <MonitorOutlined />,
      label: '监控代理',
    },
    {
      key: '3',
      icon: <AlertOutlined />,
      label: '告警管理',
    },
    {
      key: '4',
      icon: <DatabaseOutlined />,
      label: '数据管理',
    },
    {
      key: '5',
      icon: <SettingOutlined />,
      label: '系统设置',
    },
  ];

  const agentColumns = [
    {
      title: 'ID',
      dataIndex: 'id',
      key: 'id',
    },
    {
      title: '代理名称',
      dataIndex: 'name',
      key: 'name',
    },
    {
      title: '类型',
      dataIndex: 'type',
      key: 'type',
      render: (type: string) => {
        const color = type === 'system' ? 'blue' : type === 'network' ? 'green' : 'orange';
        return <Tag color={color}>{type}</Tag>;
      },
    },
    {
      title: '状态',
      dataIndex: 'status',
      key: 'status',
      render: (status: string) => {
        const color = status === 'online' ? 'green' : 'red';
        return <Tag color={color}>{status === 'online' ? '在线' : '离线'}</Tag>;
      },
    },
    {
      title: '操作',
      key: 'action',
      render: () => (
        <Space size="middle">
          <Button type="link" size="small">查看详情</Button>
          <Button type="link" size="small">重启</Button>
        </Space>
      ),
    },
  ];

  const renderDashboard = () => (
    <div>
      <Row gutter={16}>
        <Col span={6}>
          <Card>
            <Statistic
              title="CPU使用率"
              value={45.2}
              precision={1}
              valueStyle={{ color: '#3f8600' }}
              suffix="%"
            />
          </Card>
        </Col>
        <Col span={6}>
          <Card>
            <Statistic
              title="内存使用率"
              value={67.8}
              precision={1}
              valueStyle={{ color: '#cf1322' }}
              suffix="%"
            />
          </Card>
        </Col>
        <Col span={6}>
          <Card>
            <Statistic
              title="磁盘使用率"
              value={23.1}
              precision={1}
              valueStyle={{ color: '#1890ff' }}
              suffix="%"
            />
          </Card>
        </Col>
        <Col span={6}>
          <Card>
            <Statistic
              title="活跃告警"
              value={2}
              valueStyle={{ color: '#faad14' }}
              prefix={<AlertOutlined />}
            />
          </Card>
        </Col>
      </Row>
      
      <Row gutter={16} style={{ marginTop: 16 }}>
        <Col span={12}>
          <Card title="系统状态">
            {systemStatus && (
              <div>
                <p><strong>版本:</strong> {systemStatus.version}</p>
                <p><strong>运行时间:</strong> {systemStatus.uptime}</p>
                <p><strong>数据库:</strong> <Tag color="green">{systemStatus.services.database}</Tag></p>
                <p><strong>Redis:</strong> <Tag color="green">{systemStatus.services.redis}</Tag></p>
                <p><strong>Prometheus:</strong> <Tag color="green">{systemStatus.services.prometheus}</Tag></p>
                <p><strong>Elasticsearch:</strong> <Tag color="green">{systemStatus.services.elasticsearch}</Tag></p>
              </div>
            )}
          </Card>
        </Col>
        <Col span={12}>
          <Card title="快速操作">
            <Space direction="vertical" style={{ width: '100%' }}>
              <Button type="primary" block>查看系统日志</Button>
              <Button block>重启所有服务</Button>
              <Button block>导出监控数据</Button>
              <Button block>系统健康检查</Button>
            </Space>
          </Card>
        </Col>
      </Row>
    </div>
  );

  const renderAgents = () => (
    <Card title="监控代理列表">
      <Table
        columns={agentColumns}
        dataSource={agents}
        rowKey="id"
        pagination={{ pageSize: 10 }}
      />
    </Card>
  );

  const renderContent = () => {
    switch (selectedKey) {
      case '1':
        return renderDashboard();
      case '2':
        return renderAgents();
      case '3':
        return <Card title="告警管理"><p>告警管理功能开发中...</p></Card>;
      case '4':
        return <Card title="数据管理"><p>数据管理功能开发中...</p></Card>;
      case '5':
        return <Card title="系统设置"><p>系统设置功能开发中...</p></Card>;
      default:
        return renderDashboard();
    }
  };

  return (
    <Layout style={{ minHeight: '100vh' }}>
      <Sider collapsible collapsed={collapsed} onCollapse={setCollapsed}>
        <div style={{ height: 32, margin: 16, background: 'rgba(255, 255, 255, 0.3)' }} />
        <Menu
          theme="dark"
          defaultSelectedKeys={['1']}
          mode="inline"
          items={menuItems}
          onClick={({ key }) => setSelectedKey(key)}
        />
      </Sider>
      <Layout>
        <Header style={{ padding: 0, background: '#fff' }}>
          <div style={{ padding: '0 24px', fontSize: '18px', fontWeight: 'bold' }}>
            🚀 AI Monitor 智能监控系统
          </div>
        </Header>
        <Content style={{ margin: '24px 16px', padding: 24, background: '#fff' }}>
          {renderContent()}
        </Content>
      </Layout>
    </Layout>
  );
};

export default App;
EOF

    log_success "现代化前端界面创建完成"
}

# 启动服务
start_services() {
    log_info "启动AI Monitor完整服务..."
    
    # 停止可能存在的旧服务
    docker-compose down 2>/dev/null || true
    
    # 启动服务
    if docker-compose up -d; then
        log_success "服务启动成功"
    else
        log_error "服务启动失败"
        exit 1
    fi
    
    # 等待服务启动
    log_info "等待服务完全启动..."
    log_info "正在拉取Docker镜像并启动容器，首次运行可能需要较长时间..."
    sleep 30
    
    # 健康检查
    log_info "进行服务健康检查..."
    
    local max_attempts=15
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        if curl -s http://localhost:8080/health > /dev/null 2>&1; then
            log_success "后端服务健康检查通过"
            break
        else
            log_warning "后端服务健康检查失败，重试中... ($attempt/$max_attempts)"
            sleep 10
            ((attempt++))
        fi
    done
    
    if [ $attempt -gt $max_attempts ]; then
        log_error "后端服务健康检查失败，请检查服务状态"
        docker-compose logs aimonitor
        exit 1
    fi
    
    # 检查前端服务
    attempt=1
    while [ $attempt -le $max_attempts ]; do
        if curl -s http://localhost:3000 > /dev/null 2>&1; then
            log_success "前端服务健康检查通过"
            break
        else
            log_warning "前端服务健康检查失败，重试中... ($attempt/$max_attempts)"
            sleep 10
            ((attempt++))
        fi
    done
    
    if [ $attempt -gt $max_attempts ]; then
        log_warning "前端服务可能需要更多时间启动，请稍后访问"
    fi
}

# 显示部署结果
show_result() {
    clear
    echo -e "${GREEN}"
    echo "🎉🎉🎉 AI Monitor 完整版部署成功！🎉🎉🎉"
    echo -e "${NC}"
    echo -e "${BLUE}📋 部署信息:${NC}"
    echo "   项目目录: $PROJECT_DIR"
    echo "   日志文件: $LOG_FILE"
    echo ""
    echo -e "${GREEN}🌐 访问地址:${NC}"
    echo "   前端界面: http://localhost:3000"
    echo "   后端API: http://localhost:8080/api/v1/status"
    echo "   健康检查: http://localhost:8080/health"
    echo "   Prometheus: http://localhost:9090"
    echo "   Elasticsearch: http://localhost:9200"
    echo ""
    echo -e "${YELLOW}👤 默认账号:${NC}"
    echo "   用户名: admin"
    echo "   密码: admin123"
    echo ""
    echo -e "${BLUE}🔧 常用命令:${NC}"
    echo "   查看服务状态: cd $PROJECT_DIR && docker-compose ps"
    echo "   查看日志: cd $PROJECT_DIR && docker-compose logs"
    echo "   重启服务: cd $PROJECT_DIR && docker-compose restart"
    echo "   停止服务: cd $PROJECT_DIR && docker-compose down"
    echo ""
    echo -e "${GREEN}✅ 部署完成，所有服务已自动启动！${NC}"
    echo -e "${BLUE}📊 包含完整的前端界面、Prometheus监控和Elasticsearch搜索功能${NC}"
    echo -e "${YELLOW}💡 提示: 如果前端页面暂时无法访问，请等待1-2分钟让服务完全启动${NC}"
}

# 初始化Go模块
init_go_modules() {
    log_info "初始化Go模块"
    
    # 如果存在go.mod但没有go.sum，或者go.sum为空
    if [ -f "go.mod" ]; then
        if [ ! -f "go.sum" ] || [ ! -s "go.sum" ]; then
            log_info "检测到go.mod文件，但go.sum文件缺失或为空"
            log_info "正在初始化Go模块..."
            
            # 设置Go环境变量
            export GOPROXY="https://goproxy.cn,direct"
            export GOSUMDB="sum.golang.org"
            export GO111MODULE="on"
            
            # 检查是否有Go命令
            if command -v go &> /dev/null; then
                log_info "使用本地Go环境初始化模块"
                go mod download 2>/dev/null || log_warning "本地Go模块下载失败，将在Docker中处理"
                go mod tidy 2>/dev/null || log_warning "本地Go模块整理失败，将在Docker中处理"
            else
                log_info "本地未安装Go，将在Docker容器中处理模块初始化"
                # 创建空的go.sum文件，避免Docker构建时报错
                touch go.sum
            fi
            
            log_success "Go模块初始化完成"
        else
            log_success "go.sum文件已存在且不为空"
        fi
    else
        log_info "未检测到go.mod文件，跳过Go模块初始化"
    fi
}

# 主函数
main() {
    show_welcome
    setup_project_dir
    detect_os
    install_docker
    install_docker_compose
    create_project_files
    init_go_modules
    create_frontend
    start_services
    show_result
}

# 错误处理
trap 'log_error "部署过程中发生错误，请查看日志: $LOG_FILE"' ERR

# 执行主函数
main "$@"